# 컴퓨터 구조

## 2장 CPU의 구조와 기능


### CPU의 기능
>- 명령어 인출(Instruction Fetch) : 기억 장치로부터 명령어를 읽어옴
>- 명령어 해독(Instruction Decode) : 수행해야 할 동작을 결정하기 위해 명령어 해독
>&rarr; 위 두 기능은 모든 명령어에 공통으로 수행
>- 데이터 인출(Data Fetch) : 명령어 실행을 위해 데이터 필요시, 기억장치 or I/O 장치로부터 데이터 읽어옴
>- 데이터 처리(Data Process) : 데이터에 대한 산술적, 논리적 연산 수행
>- 데이터 저장(Data Store) : 수행한 결과 저장
>&rarr; 명령어에 따라 필요한 경우만 수행


### CPU의 기본 구조
>#### 산술 논리 연산 장치(ALU)
>   - 각종 산술 연산들과 논리 연산들을 수행하는 회로
>   - 산술 연산 : +,-,*,/
>   - 논리 연산 : AND, OR, NOT, XOR
>
>#### 레지스터
>   - 엑세스 속도가 가장 **빠른 기억 장치**
>   - CPU에 포함 가능한 레지스터 수 제한(특수 목적용, 일반 목적용)
>
>#### 제어 유니트
>   - 프로그램 코드(명령어)를 해석, 실행 하기위한 제어 신호를 순차적으로 발생시키는 모듈


### 명령어 실행
>#### 명령어 사이클
> : CPU가 한 개의 명령어를 실행하는데 필요한 전체 처리 과정
>
>   <img src="./Basic Instruction cycle.PNG">
>
>#### 두개의 부사이클(subcycle)들로 분리
>   - 인출 사이클(fetch cycle) : CPU가 기억 장치로부터 <u>명령어를 읽어오는 단계</u>
>   - 실행 사이클(execution cycle) : 명령어를 <u>실행하는 단계</u>
>
>#### 명령어 실행에 필요한 CPU 내부 레지스터들
>   - 프로그램 카운터(Program Counter: PC)
>       - 다음에 인출할 명령어의 주소를 가지고 있는 레지스터
>       - 각 명령어가 인출된 후에는 자동적으로 일정 크기(한 명령어 길이)만큼 증가
>
>


### 기계어의 형식
>예. <img src="./opcode,%20operand.PNG" width="50%" height="50%"/>
>
>- 연산코드(op code)
>   - 연산에 사용할 데이터 or 데이터 주소
>   - 비트 수에 따라 저장할 수 있는 주소 갯수 증가
>   - 예. 비트수 3 &rarr; 연산 수 2<sup>3</sup>
>
>- 오퍼랜드(operand)
>   - 연산에 사용할 데이터 or 데이터의 주소
>   - 비트 수에 따라 저장할 수 있는 주소 갯수 증가
>   - 비트 수 5 &rarr; 주소 수 2<sup>5</sup>


### 프로그램 코드와 데이터의 기억장치 저장
>- 프로그램 코드와 데이터는 지정된 기억장치에 저장
>- 워드 단위로 저장
>   - 워드(word) : 기억장소에 저장되는 정보의 기본단위
>   - 워드 길이 예. 8, 16, 32, 64 (bit)
>   - 주소 지정 단위 (word 혹은 byte)


### 시스템의 구성
>- 시스템 버스
>   - CPU &lrarr; 시스템 간의 정보 교환 통로
>   - 구성
>       - 주소 버스 : 외부로 발생하는 주소 정보 전송, 
>           - 주소 선의 수 : 최대 기억 장소 용량 결정
>       - 데이터 버스 : CPU &lrarr; 기억장치, I/O장치 간 데이터 전송
>           - 데이터 선의 수 : CPU가 한번에 전송할 수 있는 비트 수 결정
>       - 제어 버스 : 각종 요소의 동작을 제어하기 위한 신호선
>           - 기억 장치 읽기/쓰기
>           - I/O 읽기/쓰기
>           - 인터럽트 신호
>           - 버스 제어 신호


### CPU와 기억장치 간의 접속
>- 필요 제어 신호 : 기억장치 쓰기 신호, 기억장치 읽기 신호
>- 기억 장치 쓰기 동작 : 데이터를 저장할 기억 장소의 주소, 저장할 데이터를 각각 주소 버스와 데이터 버스를 통해 보내는 동시에 쓰기 신호 활성화
>- 기억 장치 쓰기 시간 : 주소와 데이터를 보난 순간부터 저장이 완료될 때까지
>- 기억 장치 읽기 동작 : 기억 장치 주소를 주소 버스를 통해 보내는 동시에 읽기 신호 활성화
>   - 일정 시간 경과 후 기억 장치로부터 읽은 데이터가 버스에 실리고 CPU는 버스 인터페이스 회로를 통해 읽음


### CPU와 I/O장치의 접속
>- 필요한 제어 신호 : I/O 읽기 신호, I/O 쓰기 신호
>- 접속 경로 : CPU &rlarr; 시스템 버스 &rlarr; I/O 장치 제어기
>   - I/O 장치 제어기가 왜 필요한가?
>       - 주기억장치 &rlarr; CPU 보다 느린 속도를 보완하기 위해
>       - 입력과 출력이 끝났는지 알려줌
>- I/O 장치 접속 사례 : CPU-키보드 & 프린터
>   <img src="./IO device example.png" width="80%" height="80%">
>- I/O 장치 제어기
>   - 기능 : CPU로부터 I/O 명령을 받아서, 장치 제어, 데이터 이동 등 명령을 수행
>   - 상태 레지스터
>       - I/O 장치의 현재 상태를 나타내는 비트들을 저장한 레지스터
>       - 준비 상태(RDY) 비트, 데이터 전송 확인(ACK) 비트, 등
>   - 데이터 레지스터
>       - CPU &rlarr; I/O 장치 간에 이동되는 데이터를 일시적으로 저장하는 레지스터


### 컴퓨터의 기본적인 기능들
>- 프로그램 실행 : CPU가 주 기억 장치로부터 프로그램 코드를 읽어서 실행
>- 데이터 저장 : 프로그램 실행 결과로 얻어진 데이터를 주 기억 장치에 저장
>- 데이터 이동 : 보조 저장 장치에 저장되어 있는 프로그램과 데이터 블록을 주 기억 장치로 이동
>- 데이터 입출력 : 사용자의 입력을 읽고, CPU의 처리 결과나 기억 장치의 데이터를 출력
>- 제어 : 프로그램이 순서대로 실행되도록 또는 필요에 따라 실행 순서를 변경하도록 조정, 제어 신호 발생


### 폰 노이만 아키텍쳐(von Neumann Architecture)
>- 프로그램 코드들을 기억장치에 저장된 순서대로 실행
>- 그 주소는 CPU의 내부 레지스터인 프로그램 카운터(PC)에 의해 지정
>#### 주요 부품들의 발전 과정
> 진공관 &rarr; 트랜지스터 &rarr; 집적회로(IC)
>- 집적도에 따른 IC
>   - SSI : 수십개 트랜지스터
>   - MSI : 수백개 "
>   - LSI : 수천개 "
>   - VLSI : 수만~수십만 "
>   - ULSI : 수백만개
>- IC 장점
>   - 동작 속도 크게 상승
>   - 컴퓨터 크기 감소
>   - 부품 간 신뢰도 향상
>   - 전력 소모 감소, 냉각 장치 소형화
>   - 컴퓨터 가격 하락
>   - 개인용 컴퓨터 개발 (VLSI의 출현)