# 컴퓨터 구조  

## 2장 CPU의 구조와 기능  

### CPU의 기능
>- 명령어 인출(Instruction Fetch) : 기억 장치로부터 명령어를 읽어옴
>- 명령어 해독(Instruction Decode) : 수행해야 할 동작을 결정하기 위해 명령어 해독
>   &rarr; 위 두 기능은 모든 명령어에 공통으로 수행
>- 데이터 인출(Data Fetch) : 명령어 실행을 위해 데이터 필요시, 기억장치 or I/O 장치로부터 데이터 읽어옴
>- 데이터 처리(Data Process) : 데이터에 대한 산술적, 논리적 연산 수행
>- 데이터 저장(Data Store) : 수행한 결과 저장
>   &rarr; 명령어에 따라 필요한 경우만 수행  

### CPU의 기본 구조
> #### 산술 논리 연산 장치(ALU)
>   - 각종 산술 연산들과 논리 연산들을 수행하는 회로
>   - 산술 연산 : +,-,\*,/
>   - 논리 연산 : AND, OR, NOT, XOR
>
> #### 레지스터
>   - 엑세스 속도가 가장 **빠른 기억 장치**
>   - CPU에 포함 가능한 레지스터 수 제한(특수 목적용, 일반 목적용)
>
>#### 제어 유니트
>   - 프로그램 코드(명령어)를 해석, 실행 하기위한 제어 신호를 순차적으로 발생시키는 모듈  

### 명령어 실행
>#### 명령어 사이클
> : CPU가 한 개의 명령어를 실행하는데 필요한 전체 처리 과정
>
>   <img src="../images/Basic Instruction cycle.PNG"/>
>
>#### 두개의 부사이클(subcycle)들로 분리
>   - 인출 사이클(fetch cycle) : CPU가 기억 장치로부터 <u>명령어를 읽어오는 단계</u>
>   - 실행 사이클(execution cycle) : 명령어를 <u>실행하는 단계</u>
>
>#### 명령어 실행에 필요한 CPU 내부 레지스터들
>   - 프로그램 카운터(Program Counter: PC)
>       - 다음에 인출할 명령어의 주소를 가지고 있는 레지스터
>       - 각 명령어가 인출된 후에는 자동적으로 일정 크기(한 명령어 길이)만큼 증가
>   - 누산기(Accumulator: AC) &rarr; <span style="color:#0000FF">ALU가 사용</span>
>       - 데이터를 일시적으로 저장하는 레지스터
>       - 레지스터의 길이는 CPU가 한번에 처리할 수 있는 데이터 비트 수와 동일
>   - 명령어 레지스터(Instruction Register: IR)
>       - 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터
>   - 기억장치 주소 레지스터(Memory Address Register: MAR)
>       - 프로그램 카운터에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 <u>주소 레지스터</u>
>   - 기억장치 버퍼 레지스터(Memory Buffer Register: MBR)
>       - 쓰여질 or 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터
> 
>#### 데이터 통로가 표시된 CPU 내부 구조
>   <img src="../images/CPU Internal Structure.png"/>  

### 인출 사이클
>기억장치의 지정된 위치로부터 명령어를 읽어오는 과정  
>#### 과정
>   - 각 명령어 사이클의 시작 단계에서 프로그램 카운터가 가리키는 기억장치의 위치에서 명령어 인출 &rarr; PC + 1 (여기서 1은 주소의 용량에 따라 바뀔 수 있음)
>#### 인출 사이클의 마이크로 연산  
>   <img src="../images/Fetch cycle micro operation.png"/>
>   1. 현재의 PC 내용을 CPU 내부 버스를 통해 MAR로 전송
>   2. 그 주소가 지정하는 기억장치 위치로부터 읽어진 명령어가 데이터 버스를 통해 MBR로 적재 후 PC의 주소값에 +1
>   3. MBR에 있는 명령어 코드가 명령어 레지스터인 IR로 이동
>       예. CPU 클록 주파수 = 1GHz &rarr; 클럭 주기 1ns
>       &rarr; 인출 사이클 : 1ns * 3 = 3ns 소요  

### 실행 사이클
>실행 사이클 동안 명령어 코드를 해독(Decode), 그 결과에 따라 필요한 연산 수행  
>#### CPU가 수행하는 연산의 종류
>   - 데이터 이동 : CPU와 기억장치 간 혹은 I/O장치 간에 데이터를 이동
>   - 데이터 처리 : 데이터에 대해 산술, 논리 연산 수행
>   - 데이터 저장 : 연산 결과 데이터 혹은 입력장치로부터 읽어온 데이터를 기억장치에 저장
>   - 프로그램 제어 : 프로그램 실행 순서 결정
>실행 사이클에서 수행되는 마이크로 연산들은 명령어의 종류에 따라 다름  
  
### 기본적인 명령어 형식의 구성
>#### 연산 코드(Operation Code)  
>   - CPU가 수행할 연산을 지정
>#### 오퍼랜드(Operand)  
>   - 명령어 실행에 필요한 데이터가 저장된 주소  
>   <img src="../images/opcode, operand.PNG" width="80%" height="80%"/>  

### 어셈블리 프로그램 실행과정의 예
><img src="../images/assembly program execution example 1.png"/>  
>
><img src="../images/assembly program execution example 2.png"/>  
>
><img src="../images/assembly program execution example 3.png"/>  
>
><img src="../images/assembly program execution example 4.png"/>  
>
><img src="../images/assembly program execution example 5.png"/>  

### 인터럽트 사이클
>#### 인터럽트  
>   - 프로그램을 실행 중에 중단시키고 다른 동작을 수행하게 만드는 시스템 동작  
>#### 인터럽트 서비스 루틴(interrupt service routine: ISR)  
>   - 인터럽트를 처리하기 위해 수행되는 프로그램 루틴  
>인터럽트에 의한 제어의 이동  
>   <img src="../images/interrupt flow.png"/>  
>
>#### 인터럽트 처리 과정
>   1. 현재의 명령어 실행을 끝낸 즉시, 다음에 실행할 명령어의 주소(PC의 내용)를 스택에 저장  
>       &rarr; 일반적으로 스택은 주 기억장치의 특정 부분  
>   2. ISR을 호출하기 위해 인터럽트 서비스 루틴의 시작주소를 PC에 적재  
>       &rarr; 이 때 시작주소는 인터럽트를 요구한 장치에서 전송 또는 미리 정해진 값으로 결정  
>
>#### 인터럽트 사이클이 추가된 명령어 사이클  
>   <img src="../images/interrupt cycle added instruction cycle.png"/>  
>
>#### 인터럽트 사이클의 마이크로 연산 예시  
>   <img src="../images/interrupt cycle micro operation example 1.png"/>  
>   <img src="../images/interrupt cycle micro operation example 2.png"/>  
>
>#### 다중 인터럽트 처리방법  
>   1. CPU가 인터럽트 서비스 루틴을 처리하고 있는 도중에는 새로운 인터럽트 요구가 들어와도 무시  
>       - 인터럽트 플래그 &larr; 0 : 인터럽트 불가 상태  
>       - 도중에 중단 불가능한 인터럽트 처리 시 사용  
>   2. 인터럽트의 <u>우선순위</u>를 정하고, 우선순위가 높은 인터럽트 일 경우에 먼저 처리  

### 간접 사이클
>명령어에 포함되어 있는 주소를 이용, 그 명령어 실행에 필요한 데이터 주소를 인출하는 사이클  
>   &rarr; 간접 주소지정 방식에서 사용  
>인출 사이클과 실행 사이클 사이에 위치  

### 명령어 파이프라이닝
>CPU의 프로그램 처리속도를 높이기 위해 CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술  
>
>#### 2단계 파이프라인과 시간 흐름도  
>   <img src="../images/2-stage pipeline time flow.png"/>  
>   - 명령어 처리 속도 2배 향상  
>   - 문제점 : 두 단계의 처리 시간이 동일하지 않으면 효율 저하  
>
>#### 4단계 명령어 파이프라인  
>   - 명령어 인출(IF) 단계 : 다음 명령어를 기억장치로부터 인출  
>   - 명령어 해독(ID) 단계 : 해독기(Decoder)를 이용해서 명령어를 해석  
>   - 오퍼랜드 인출(OF) 단계 : 기억장치로부터 오퍼랜드를 인출  
>   - 실행(EX) 단계 : 지정된 연산 수행  
>   - 4단계 파이프라인과 시간 흐름도  
>   <img src="../images/4-stage pipeline time flow.png"/>  
>#### 파이프라인에 의한 전체 명령어 실행 시간  
>   - 파이프라인 단계 수 = k  
>   - 실행할 명령어 수 = N  
>   - 파이프라인 단계가 한 클록 주기씩 걸린다고 가정  
>       &rarr; 파이프라인에 의한 전체 명령어 실행시간  
>       : T = k + (N - 1)  

### 상태 레지스터
>명령어 실행 결과에 따른 조건 플래그 저장  
>   <img src="../images/status register.png" />
>   **X는 빈 비트이다.**  
>종류  
>   - 부호 플래그(S) : 직전에 수행된 산술연산 결과값의 부호 비트를 저장 (양수 , 음수 1)  
>   - 영 플래그(Z) : 연산 결과값이 이면 1로 세트 (주로 조건문에서 사용)  
>   - 올림수 플래그(C) : 덧셈이나 뺄셈에서 올림수나 빌림수가 발생한 경우에 1로 세트  
>   - 동등 플래그(E) : 두 수를 비교한 결과가 같게 나왔을 경우 1로 세트  
>   - 오버플로우 플래그(V) : 산술연산 중 오버플로우가 발생했을 경우 1로 세트  
>   - 인터럽트 플래그(I) : 