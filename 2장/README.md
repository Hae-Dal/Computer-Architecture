# 컴퓨터 구조  
  
## 2장 CPU의 구조와 기능  
  
### CPU의 기능
>- 명령어 인출(Instruction Fetch) : 기억 장치로부터 명령어를 읽어옴  
>- 명령어 해독(Instruction Decode) : 수행해야 할 동작을 결정하기 위해 명령어 해독  
>   &rarr; 위 두 기능은 모든 명령어에 공통으로 수행  
>- 데이터 인출(Data Fetch) : 명령어 실행을 위해 데이터 필요시, 기억장치 or I/O 장치로부터 데이터 읽어옴  
>- 데이터 처리(Data Process) : 데이터에 대한 산술적, 논리적 연산 수행  
>- 데이터 저장(Data Store) : 수행한 결과 저장  
>   &rarr; 명령어에 따라 필요한 경우만 수행  
  
### CPU의 기본 구조
> #### 산술 논리 연산 장치(ALU)
>   - 각종 산술 연산들과 논리 연산들을 수행하는 회로  
>   - 산술 연산 : +,-,\*,/  
>   - 논리 연산 : AND, OR, NOT, XOR  
>
> #### 레지스터
>   - 엑세스 속도가 가장 **빠른 기억 장치**
>   - CPU에 포함 가능한 레지스터 수 제한(특수 목적용, 일반 목적용)
>
>#### 제어 유니트
>   - 프로그램 코드(명령어)를 해석, 실행 하기위한 제어 신호를 순차적으로 발생시키는 모듈  
  
### 명령어 실행
>#### 명령어 사이클
> : CPU가 한 개의 명령어를 실행하는데 필요한 전체 처리 과정  
>   <img src="../images/Basic Instruction cycle.PNG"/>  
>
>#### 두개의 부사이클(subcycle)들로 분리
>   - 인출 사이클(fetch cycle) : CPU가 기억 장치로부터 <u>명령어를 읽어오는 단계</u>  
>   - 실행 사이클(execution cycle) : 명령어를 <u>실행하는 단계</u>  
>
>#### 명령어 실행에 필요한 CPU 내부 레지스터들
>   - 프로그램 카운터(Program Counter: PC)  
>       - 다음에 인출할 명령어의 주소를 가지고 있는 레지스터  
>       - 각 명령어가 인출된 후에는 자동적으로 일정 크기(한 명령어 길이)만큼 증가  
>   - 누산기(Accumulator: AC) &rarr; **ALU가 사용**  
>       - 데이터를 일시적으로 저장하는 레지스터  
>       - 레지스터의 길이는 CPU가 한번에 처리할 수 있는 데이터 비트 수와 동일  
>   - 명령어 레지스터(Instruction Register: IR)  
>       - 가장 최근에 인출된 명령어 코드가 저장되어 있는 레지스터  
>   - 기억장치 주소 레지스터(Memory Address Register: MAR)  
>       - 프로그램 카운터에 저장된 명령어 주소가 시스템 주소 버스로 출력되기 전에 일시적으로 저장되는 <u>주소 레지스터</u>  
>   - 기억장치 버퍼 레지스터(Memory Buffer Register: MBR)  
>       - 쓰여질 or 읽혀진 데이터를 일시적으로 저장하는 버퍼 레지스터  
> 
>#### 데이터 통로가 표시된 CPU 내부 구조
>   <img src="../images/CPU Internal Structure.png"/>  
  
### 인출 사이클
>기억장치의 지정된 위치로부터 명령어를 읽어오는 과정  
>#### 과정
>   - 각 명령어 사이클의 시작 단계에서 프로그램 카운터가 가리키는 기억장치의 위치에서 명령어 인출 &rarr; PC + 1 (여기서 1은 주소의 용량에 따라 바뀔 수 있음)
>#### 인출 사이클의 마이크로 연산  
>   <img src="../images/Fetch cycle micro operation.png"/>  
>   1. 현재의 PC 내용을 CPU 내부 버스를 통해 MAR로 전송  
>   2. 그 주소가 지정하는 기억장치 위치로부터 읽어진 명령어가 데이터 버스를 통해 MBR로 적재 후 PC의 주소값에 +1  
>   3. MBR에 있는 명령어 코드가 명령어 레지스터인 IR로 이동  
>       예. CPU 클록 주파수 = 1GHz &rarr; 클럭 주기 1ns  
>       &rarr; 인출 사이클 : 1ns * 3 = 3ns 소요  
  
### 실행 사이클
>실행 사이클 동안 명령어 코드를 해독(Decode), 그 결과에 따라 필요한 연산 수행  
>#### CPU가 수행하는 연산의 종류
>   - 데이터 이동 : CPU와 기억장치 간 혹은 I/O장치 간에 데이터를 이동  
>   - 데이터 처리 : 데이터에 대해 산술, 논리 연산 수행  
>   - 데이터 저장 : 연산 결과 데이터 혹은 입력장치로부터 읽어온 데이터를 기억장치에 저장  
>   - 프로그램 제어 : 프로그램 실행 순서 결정  
>실행 사이클에서 수행되는 마이크로 연산들은 명령어의 종류에 따라 다름  
  
### 기본적인 명령어 형식의 구성
>#### 연산 코드(Operation Code)  
>   - CPU가 수행할 연산을 지정  
>#### 오퍼랜드(Operand)  
>   - 명령어 실행에 필요한 데이터가 저장된 주소  
>   <img src="../images/opcode, operand.PNG" width="80%" height="80%"/>  
  
### 어셈블리 프로그램 실행과정의 예
><img src="../images/assembly program execution example 1.png"/>  
>
><img src="../images/assembly program execution example 2.png"/>  
>
><img src="../images/assembly program execution example 3.png"/>  
>
><img src="../images/assembly program execution example 4.png"/>  
>
><img src="../images/assembly program execution example 5.png"/>  
  
### 인터럽트 사이클
>#### 인터럽트  
>   - 프로그램을 실행 중에 중단시키고 다른 동작을 수행하게 만드는 시스템 동작  
>#### 인터럽트 서비스 루틴(interrupt service routine: ISR)  
>   - 인터럽트를 처리하기 위해 수행되는 프로그램 루틴  
>#### 인터럽트에 의한 제어의 이동  
>   <img src="../images/interrupt flow.png"/>  
>
>#### 인터럽트 처리 과정
>   1. 현재의 명령어 실행을 끝낸 즉시, 다음에 실행할 명령어의 주소(PC의 내용)를 스택에 저장  
>       &rarr; 일반적으로 스택은 주 기억장치의 특정 부분  
>   2. ISR을 호출하기 위해 인터럽트 서비스 루틴의 시작주소를 PC에 적재  
>       &rarr; 이 때 시작주소는 인터럽트를 요구한 장치에서 전송 또는 미리 정해진 값으로 결정  
>
>#### 인터럽트 사이클이 추가된 명령어 사이클  
>   <img src="../images/interrupt cycle added instruction cycle.png"/>  
>
>#### 인터럽트 사이클의 마이크로 연산 예시  
>   <img src="../images/interrupt cycle micro operation example 1.png"/>  
>   <img src="../images/interrupt cycle micro operation example 2.png"/>  
>
>#### 다중 인터럽트 처리방법  
>   1. CPU가 인터럽트 서비스 루틴을 처리하고 있는 도중에는 새로운 인터럽트 요구가 들어와도 무시  
>       - 인터럽트 플래그 &larr; 0 : 인터럽트 불가 상태  
>       - 도중에 중단 불가능한 인터럽트 처리 시 사용  
>   2. 인터럽트의 <u>우선순위</u>를 정하고, 우선순위가 높은 인터럽트 일 경우에 먼저 처리  
  
### 간접 사이클
>명령어에 포함되어 있는 주소를 이용, 그 명령어 실행에 필요한 데이터 주소를 인출하는 사이클  
>   &rarr; 간접 주소지정 방식에서 사용  
>인출 사이클과 실행 사이클 사이에 위치  
  
### 명령어 파이프라이닝
>CPU의 프로그램 처리속도를 높이기 위해 CPU 내부 하드웨어를 여러 단계로 나누어 동시에 처리하는 기술  
>
>#### 2단계 파이프라인과 시간 흐름도  
>   <img src="../images/2-stage pipeline time flow.png"/>  
>   - 명령어 처리 속도 2배 향상  
>   - 문제점 : 두 단계의 처리 시간이 동일하지 않으면 효율 저하  
>
>#### 4단계 명령어 파이프라인  
>   - 명령어 인출(IF) 단계 : 다음 명령어를 기억장치로부터 인출  
>   - 명령어 해독(ID) 단계 : 해독기(Decoder)를 이용해서 명령어를 해석  
>   - 오퍼랜드 인출(OF) 단계 : 기억장치로부터 오퍼랜드를 인출  
>   - 실행(EX) 단계 : 지정된 연산 수행  
>   - 4단계 파이프라인과 시간 흐름도  
>   <img src="../images/4-stage pipeline time flow.png"/>  
>#### 파이프라인에 의한 전체 명령어 실행 시간  
>   - 파이프라인 단계 수 = k  
>   - 실행할 명령어 수 = N  
>   - 파이프라인 단계가 한 클록 주기씩 걸린다고 가정  
>       &rarr; 파이프라인에 의한 전체 명령어 실행시간  
>       : T = k + (N - 1)  
  
### 상태 레지스터
>명령어 실행 결과에 따른 조건 플래그 저장  
>   <img src="../images/status register.png" />  
>   **X는 빈 비트이다.**  
>#### 종류  
>   - 부호 플래그(S) : 직전에 수행된 산술연산 결과값의 부호 비트를 저장 (양수 , 음수 1)  
>   - 영 플래그(Z) : 연산 결과값이 이면 1로 세트 (주로 조건문에서 사용)  
>   - 올림수 플래그(C) : 덧셈이나 뺄셈에서 올림수나 빌림수가 발생한 경우에 1로 세트  
>   - 동등 플래그(E) : 두 수를 비교한 결과가 같게 나왔을 경우 1로 세트  
>   - 오버플로우 플래그(V) : 산술연산 중 오버플로우가 발생했을 경우 1로 세트  
>   - 인터럽트 플래그(I) : 인터럽트 가능 &rarr; 0, 인터럽트 불가능 &rarr; 1로 세트  
>   - 슈퍼바이저 플래그(P) : CPU의 실행모드가 슈퍼바이저 &rarr; 1, 사용자 &rarr; 0으로 세트
  
### 슈퍼스칼라
-의미만 알아두기
>CPU의 처리 속도를 더욱 높이기 위해 내부에 2개 이상의 명령어 파이프라인을 포함시킨 구조  
  
### 듀얼-코어 및 멀티-코어
>#### CPU 코어(core)
>   - 명령어 실행에 필요한 내부의 **핵심 하드웨어 모듈** (슈퍼스칼라 H/W, ALU, 레지스터 등)  
>#### 멀티-코어 프로세서(multi-core processor)
>   - 여러개의 CPU 코어들을 하나의 칩에 포함시킨 프로세서  
>   - 듀얼, 쿼드, 헥사 etc.  
>**칩-레벨 다중프로세서 또는 단일-칩 다중프로세서라고 부름**  
>#### 듀얼-코어 프로세서
>   - 단일-코어 슈퍼스칼라 프로세서에 비해 2배의 속도 향상 기대  
>   <img src="../images/dual core processor.png"/>  
>   **CPU는 1개, 코어가 2개, 버스 인터페이스 및 캐시는 1개이기때문에 버스 및 캐시를 사용하는 작업은 동시에 불가**  
>#### 멀티-스레딩
>   - 스레드 : 독립적으로 실행될 수 있는 최소 크기의 프로그램 단위
>   - 단일-스레드 모델 : 각 코어가 스레드 한 개씩 처리
>       - 처리 중의 스레드에 대한 시스템 상태, 데이터 및 주소 정보를 레지스터 세트(RS)에 저장
>       - RS : PC, SP, SR, MAR, MBR etc.
>   - 멀티-스레드 모델 : 각 코어가 스레드 두 개씩 처리
>       - 코어 당 레지스터 세트(RS) 2개  
  
### 명령어 세트
>어떤 CPU를 위해 정의되어 있는 명령어들의 집합  
>#### 설계를 위해 결정되어야 할 사항
>   - 연산 종류 : CPU가 수행할 연산들의 수와 종류 및 복잡도
>   - 데이터 형태 : 연산을 수행할 데이터들의 형태, 길이, 표현 방식  
>   - 명령어 형식 : 명령어 길이, 오퍼랜드 필드 수와 길이 
>   - 주소지정 방식 : 오퍼랜드의 주소를 지정하는 방식(직접 주소, 간접 주소)  
>  
>#### 연산 종류  
>   - 데이터 전송 : 레지스터, 기억장치 등 장치 간 데이터를 이동하는 동작
>   - 산술 연산 : 덧셈, 뺄셈, 곱셈 및 나눗셈과 같은 기본적인 산술 연산
>   - 논리 연산 : 데이터의 비트 간 AND, OR, NOT 및 exclusive-OR 연산
>   - 입출력(I/O) : CPU와 외부 장치들 간의 데이터 이동을 위한 동작들
>   - 프로그램 제어
>       - 명령어 실행 순서를 변경하는 연산들
>       - 분기(branch), 서브루틴 호출(subroutine call)  
>           &rarr; 반드시 스택 사용(stack pointer: SP)  
>  
>#### 서브루틴 호출을 위한 명령어  
>   - CALL 명령어 : 현재의 PC내용을 스택에 저장, 서브루틴 시작주소로 분기(GoTo와 비슷함)  
>   - RET 명령어 : CPU가 원래 실행하던 프로그램으로 복귀(return)시키는 명령어  
>   <img src="../images/subroutine execution sequence.png"/>

### 명령어 형식  
>#### 명령어의 구성요소들  
>   - 연산코드 : 수행될 연산 지정 (예. LOAD, ADD etc.)  
>   - 오퍼랜드 : 연산 수행에 필요한 데이터 or 데이터 주소  
>   - 다음 명령어 주소 : 분기 혹은 호출 명령어와 같이 실행 순서를 변경하는 경우 필요
>   - 필드 : 명령어의 각 구성 요소들에 소요되는 비트 그룹
>   - 명령어 길이 : 단어(word) 길이  
>   <img src="../images/Instruction format.png"/>  
>   **오퍼랜드1은 보통 ALU에서 사용하는 레지스터이며, 오퍼랜드2는 보통 주소값이다.**
>#### 오퍼랜드 수에 따른 명령어 분류  
>   - 1 주소 명령어 : 오퍼랜드를 한 개만 포함하는 명령어
>       - 예. <img src="../images/1 address instruction example.png"/>  
>   - 2 주소 명령어 : 두 개의 오퍼랜드를 포함하는 명령어
>       - 예. <img src="../images/2 address instruction example.png"/>
>   - 3 주소 명령어 : 세 개의 오퍼랜드를 포함하는 명령어
>       - 예. <img src="../images/3 address instruction example.png"/>
>